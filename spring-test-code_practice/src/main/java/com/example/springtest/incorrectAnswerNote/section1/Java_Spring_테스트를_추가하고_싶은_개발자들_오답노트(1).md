# 테스트의 필요성과 테스트 3분류
레거시 코드란 단순하게 생각해서 오래되고, 유지보수가 되지 않는 코드라고 생각하기 쉽다. 
마이클 페더스는 '내게 레거시 코드란, 단순히 테스트 루틴이 없는 코드다. 다만 이 정의는 다소 불완전하다' 라고 말했다.   
시간과 관련되는 말이 아니라 테스트가 없다면 레거시라고 볼 수 있는거다.   

### 필요성
테스트는 왜 필요한가? Regression 문제 때문이다. 
이전에 잘 동작하던 코드가 이번 배포로 인해서 동작하지 않는 상황을 Regression이라고 한다. 테스트의 목적은 Regression을 방지하고, 좋은 설계(SOLID)를 갖기 위해 필요한것이다.  

### 테스트와 SOLID
- S 단일 책임 원칙 : 테스트는 명료하고 간단하게 작성해야하기 때문에, 단일 책임 원칙을 지키게 된다.
    - 테스트가 너무 많아져서 이게 무슨 목적의 클래스인지 눈에 안들어오는 지점이 생기고, 이 때가 클래스를 분할해야 하는 시점이다. 그러면서 책임이 자연스럽게 분배된다.
- O 개방 폐쇄 원칙 : 테스트 컴포넌트와 프로덕션 컴포넌트를 나눠 작업하게 되고 필요에 따라 이 컴포넌트를 자유자재로 탈부착이 가능하게 개발하게 된다.  
- L 리스코프 치환 원칙 : 이상적으로 테스트는 모든 케이스에 대해 커버하고 있으므로, 서브 클래스에 대한 치환 여부를 테스트가 알아서 판단해준다.  
- I 인터페이스 분리 원칙 : 테스트는 그 자체로 인터페이스를 직접 사용해볼 수 있는 환경으로 불필요한 의존성을 실제로 확인할 수 있는 샌드박스 역할을 한다. 
- D 의존 역전 원칙 : 가짜 객체를 이용하여 테스트를 작성하려면, 의존성이 역전되어 있어야 하는 경우가 생긴다.  

다만, 테스트가 SOLID를 강제하는 것은 아니고, 테스트를 넣으면서 이런 것들도 함께 챙겨야 하고, 어떻게 테스트할까 를 고민하다 보면 자연스럽게 SOLID가 따라오게 된다.  


### 전통적인 테스트 3분류
전통적으로는 API 테스트, 통합 테스트, 단위 테스트 이렇게  3가지로 분류되지만, 사람마다 정의하는게 다르고 분류도 애매하다.  
구글에서는 3가지 용어를 사용하지 않고, large(대형), medium(중형), small(소형) 테스트로 분류해서 사용한다.

1. small(소형) 테스트
   - 단일 서버, 단일 프로세스, 단일 스레드, 디스트 I/O 사용 불가, Blocking call 허용 불가
2. medium(중형) 테스트
    - 단일 서버, 멀티 프로세스, 멀티 스레드 -> h2같은 테스트 DB를 사용할 수 있다.
3. large(대형) 테스트
    - 멀티 서버, E2E 테스트
-  중형 테스트가 많아지면 많아질수록 속도는 당연히 느려진다. 따라서 우리가 집중해야 하는 것은 소형 테스트다.

# 테스트에 필요한 개념
1. SUT(System under test) : 테스트 하려는 대상
2. BDD(Behaviour driven development) : given - when - then   
    - 테스트를 작성하다보면, 어디에 어떻게 테스트를 넣어야할까? 라는 질문을 마주하게 된다. 이때, BDD에서는 '행동'에 집중해야 한다고 한다.
    - 그래서 유저가 시스템을 사용하는 user story를 강조하고 시나리오를 강조한다. 
3. 상호 작용 테스트 (Interaction test) : 대상 함수의 구현을 호출하지 않으면서 그 함수가 어떻게 호출되는지를 검증하는 기법
4. 상태 기반 검증 : 어떤 값을 시스템에 넣었을 때, 나오는 결괏값을 기댓값과 비교하는 방식
5. 행위 기반 검증 : 어떤 값을 시스템에 넣었을 때, 협력 객체의 어떤 메서드를 실행하는가? 
6. 테스트 픽스처 : 테스트를 하기 위해 필요한 자원을 미리 생성하는 것 
7. Testability : 테스트 가능성, 소프트웨어가 테스트 가능한 구조인가?
8. test double : 테스트 대역(특정 테스트에 필요한 역할을 대역에게 시키는거)
    - 1. Dummy : 아무런 동작도 하지 않고, 그저 코드가 정상저긍로 돌아가기 위해 전달하는 객체
    - 2. Fake : Local에서 사용하거나 테스트에서 사용하기위해 만들어진 가짜, 자체적인 로직이 있다는게 특징이다.
    - 3. Stub : 미리 준비된 값을 출력하는 객체이다.
    - 4. Mock : 메서드 호출을 하기 위한 객체, 자가 검증 능력을 갖춤, 사실상 테스트 더블과 동일한 의미로 사용된다.
    - 5. Spy : 메서드 호출을 전부 기록했다가 나중에 확인하기 위한 객체이다.

- 테스트가 쌓이고 잘 만들어지면 정책이 되고, 계약이 된다...


# 의존성
의존성이란 컴퓨터 공학에서는 결합(Coupling)과 같은 개념이다. A는 B를 사용하기만 해도 의존한다고 할 수 있다.  
이러한 의존성을 약화시키는 테크닉으로 의존성 결합(Dependency Injection)을 사용한다. 하지만 의존성 주입이 의존성을 완전히 없애는 방식은 아니다.  
의존성을 완전 없애는건 불가능하다. 객체간의 협력이 프로그래밍이기 때문이다. 디자인 패턴 같은것들이 어떻게 하면 의존성을 약화 시킬 수 있을까에 대한 고민 결과다.  

## 의존성 주입
- 인스턴스를 만드는 것보다 의존성 주입을 받는게 좋은 이유는?
   - new는 사실상 하드 코딩이다. 당연하게도 하나의 객체를 new로 생성하는것보다 외부에서 주입을 받으면 훨씬 자유롭게 주입 받아 사용할 수 있다. 

````java
import javax.xml.transform.Source;

class Chef {
   public Hambuger makeHamburger() {
      Bread bread = new Bread();
      Meat meat = new Meat();
      Lettuce lettuce = new Lettuce();
      Source source = new Source();
      return Hamburger.builder()
              .bread(bread)
              .meat(meat)
              .lettuce(lettuce)
              .source(source)
              .build();
   }
}
````
## 의존성 역전
- Dependency Injection과 Dependency Inversion은 다르다.
  - Dependency Injection : 의존성 주입 (DI) 
  - Dependency Inversion : 의존성 역전 (SOLID-DIP)

1. 의존성 역전이란?
   - 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.
   - 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.
2. 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안 된다. 대신 세부사항이 정책에 의존해야 한다.

# 의존성과 테스트
테스트를 잘 하려면 의존성 주입과 역전을 잘 다룰 수 있어야 한다.  
SOLID -> DIP : 의존성 역전 원칙, 대부분의 소프트웨어 문제는 의존성 역전으로 해결이 가능하다.

# Testability 테스트 가능성
얼마나 쉽게 input을 변경하고, output을 쉽게 검증할 수 있는가?
1. 파일이 존재하지 않을 때를 테스트 할 수 없다.
2. 하드 코딩된 외부 시스템과 연동이 되어있는 경우
3. 외부에서 결과를 볼 수 없는 경우

# 참고 
### DRY < DAMP
테스트와 코드 공유 : DRY가 아니라 DAMP : 테스트할 때만큼은 '중복이 되더라도 가독성이 좋은게 낫다'
- DRY (건조한) : Don't Repeat Yourself (반복하지 않기)
- DAMP (습한) : Descriptive And Meaningful Phrase (서술적이고 의미 있는 문구)

### 논리 로직을 피하라 (+, for, if)
테스트에 논리를 넣지 마라
